{
  "version": 3,
  "sources": ["../src/controllers/HMSHLSPlayer.ts", "../src/controllers/HMSHLSTimedMetadata.ts", "../src/error/HMSHLSException.ts", "../src/utilies/constants.ts", "../src/error/HMSHLSErrorFactory.ts", "../src/utilies/utils.ts", "../src/interfaces/events.ts"],
  "sourcesContent": ["import { HlsPlayerStats, HlsStats } from '@100mslive/hls-stats';\nimport Hls, { ErrorData, HlsConfig, Level, LevelParsed } from 'hls.js';\nimport { HMSHLSTimedMetadata } from './HMSHLSTimedMetadata';\nimport { HMSHLSErrorFactory } from '../error/HMSHLSErrorFactory';\nimport { HMSHLSException } from '../error/HMSHLSException';\nimport { HMSHLSPlayerEventEmitter, HMSHLSPlayerListeners, IHMSHLSPlayerEventEmitter } from '../interfaces/events';\nimport { HMSHLSLayer } from '../interfaces/IHMSHLSLayer';\nimport IHMSHLSPlayer from '../interfaces/IHMSHLSPlayer';\nimport { HLS_DEFAULT_ALLOWED_MAX_LATENCY_DELAY, HLSPlaybackState, HMSHLSPlayerEvents } from '../utilies/constants';\nimport { mapLayer, mapLayers } from '../utilies/utils';\n\nexport class HMSHLSPlayer implements IHMSHLSPlayer, IHMSHLSPlayerEventEmitter {\n  private _hls: Hls;\n  private _hlsUrl: string;\n  private _hlsStats: HlsStats;\n  private _videoEl: HTMLVideoElement;\n  private _emitter: HMSHLSPlayerEventEmitter;\n  private _subscribeHlsStats?: (() => void) | null = null;\n  private _isLive: boolean;\n  private _volume: number;\n  private _metaData: HMSHLSTimedMetadata;\n  private readonly TAG = '[HMSHLSPlayer]';\n  /**\n   * Initiliaze the player with hlsUrl and video element\n   * @remarks If video element is not passed, we will create one and call a method getVideoElement get element\n   * @param hlsUrl required - Pass hls url to\n   * @param videoEl optional field - HTML video element\n   */\n  constructor(hlsUrl: string, videoEl?: HTMLVideoElement) {\n    this._hls = new Hls(this.getPlayerConfig());\n    this._emitter = new HMSHLSPlayerEventEmitter();\n    this._hlsUrl = hlsUrl;\n    this._videoEl = videoEl || this.createVideoElement();\n    if (!hlsUrl) {\n      throw HMSHLSErrorFactory.HLSMediaError.hlsURLNotFound();\n    } else if (!hlsUrl.endsWith('m3u8')) {\n      throw HMSHLSErrorFactory.HLSMediaError.hlsURLNotFound('Invalid URL, pass m3u8 url');\n    }\n    this._hls.loadSource(hlsUrl);\n    this._hls.attachMedia(this._videoEl);\n    this._isLive = true;\n    this._volume = this._videoEl.volume * 100;\n    this._hlsStats = new HlsStats(this._hls, this._videoEl);\n    this.listenHLSEvent();\n    this._metaData = new HMSHLSTimedMetadata(this._hls, this._videoEl, this.emitEvent);\n    this.seekToLivePosition();\n  }\n\n  /**\n   * @remarks It will create a video element with playiniline true.\n   * @returns HTML video element\n   */\n  private createVideoElement(): HTMLVideoElement {\n    if (this._videoEl) {\n      return this._videoEl;\n    }\n    const video: HTMLVideoElement = document.createElement('video');\n    video.playsInline = true;\n    video.controls = false;\n    video.autoplay = true;\n    return video;\n  }\n  /**\n   * @returns get html video element\n   */\n  getVideoElement(): HTMLVideoElement {\n    return this._videoEl;\n  }\n  /**\n   *  Subscribe to hls stats\n   */\n  private subscribeStats = (interval = 2000) => {\n    this._subscribeHlsStats = this._hlsStats.subscribe((state: HlsPlayerStats) => {\n      this.emitEvent(HMSHLSPlayerEvents.STATS, state);\n    }, interval);\n  };\n  /**\n   * Unsubscribe to hls stats\n   */\n  private unsubscribeStats = () => {\n    if (this._subscribeHlsStats) {\n      this._subscribeHlsStats();\n    }\n  };\n  // reset the controller\n  reset() {\n    if (this._hls && this._hls.media) {\n      this._hls.detachMedia();\n      this.unsubscribeStats();\n    }\n    if (this._metaData) {\n      this._metaData.unregisterListener();\n    }\n    if (Hls.isSupported()) {\n      this._hls.off(Hls.Events.MANIFEST_LOADED, this.manifestLoadedHandler);\n      this._hls.off(Hls.Events.LEVEL_UPDATED, this.levelUpdatedHandler);\n      this._hls.off(Hls.Events.ERROR, this.handleHLSException);\n    }\n    if (this._videoEl) {\n      this._videoEl.removeEventListener('play', this.playEventHandler);\n      this._videoEl.removeEventListener('pause', this.pauseEventHandler);\n      this._videoEl.removeEventListener('timeupdate', this.handleTimeUpdateListener);\n      this._videoEl.removeEventListener('volumechange', this.volumeEventHandler);\n    }\n    this.removeAllListeners();\n  }\n\n  on = <E extends HMSHLSPlayerEvents>(eventName: E, listener: HMSHLSPlayerListeners<E>) => {\n    this._emitter.on(eventName, listener);\n  };\n\n  off = <E extends HMSHLSPlayerEvents>(eventName: E, listener: HMSHLSPlayerListeners<E>) => {\n    this._emitter.off(eventName, listener);\n  };\n\n  emitEvent = <E extends HMSHLSPlayerEvents>(\n    eventName: E,\n    eventObject: Parameters<HMSHLSPlayerListeners<E>>[0],\n  ): boolean => {\n    if (eventName === HMSHLSPlayerEvents.ERROR) {\n      const hlsError = eventObject as HMSHLSException;\n      if (hlsError?.isTerminal) {\n        // send analytics event\n        window?.__hms?.sdk?.sendHLSAnalytics(hlsError);\n      }\n    }\n    return this._emitter.emitEvent(eventName, eventObject);\n  };\n\n  private removeAllListeners = <E extends HMSHLSPlayerEvents>(eventName?: E): void => {\n    this._emitter.removeAllListeners(eventName);\n  };\n\n  public get volume(): number {\n    return this._volume;\n  }\n\n  setVolume(volume: number) {\n    this._videoEl.volume = volume / 100;\n    this._volume = volume;\n  }\n\n  getLayer(): HMSHLSLayer | null {\n    if (this._hls && this._hls.currentLevel !== -1) {\n      const currentLevel = this._hls?.levels.at(this._hls?.currentLevel);\n      return currentLevel ? mapLayer(currentLevel) : null;\n    }\n    return null;\n  }\n\n  setLayer(layer: HMSHLSLayer): void {\n    if (this._hls) {\n      const current = this._hls.levels.findIndex((level: Level) => {\n        return level?.attrs?.RESOLUTION === layer?.resolution;\n      });\n      this._hls.currentLevel = current;\n    }\n    return;\n  }\n  /**\n   * set current stream to Live\n   */\n  async seekToLivePosition() {\n    let end = 0;\n    if (this._videoEl.buffered.length > 0) {\n      end = this._videoEl.buffered.end(this._videoEl.buffered.length - 1);\n    }\n    this._videoEl.currentTime = this._hls.liveSyncPosition || end;\n    if (this._videoEl.paused) {\n      try {\n        await this.playVideo();\n      } catch (err) {\n        console.error(this.TAG, 'Attempt to jump to live position Failed.', err);\n      }\n    }\n  }\n  /**\n   * Play stream\n   */\n  play = async () => {\n    await this.playVideo();\n  };\n  /**\n   * Pause stream\n   */\n  pause = () => {\n    this.pauseVideo();\n  };\n  /**\n   * It will update the video element current time\n   * @param seekValue Pass currentTime in second\n   */\n  seekTo = (seekValue: number) => {\n    this._videoEl.currentTime = seekValue;\n  };\n\n  private playVideo = async () => {\n    try {\n      if (this._videoEl.paused) {\n        await this._videoEl.play();\n      }\n    } catch (error) {\n      console.debug(this.TAG, 'Play failed with error', (error as Error).message);\n      if ((error as Error).name === 'NotAllowedError') {\n        this.emitEvent(HMSHLSPlayerEvents.AUTOPLAY_BLOCKED, HMSHLSErrorFactory.HLSMediaError.autoplayFailed());\n      }\n    }\n  };\n  private pauseVideo = () => {\n    if (!this._videoEl.paused) {\n      this._videoEl.pause();\n    }\n  };\n  private playEventHandler = () => {\n    this.emitEvent(HMSHLSPlayerEvents.PLAYBACK_STATE, {\n      state: HLSPlaybackState.playing,\n    });\n  };\n  private pauseEventHandler = () => {\n    this.emitEvent(HMSHLSPlayerEvents.PLAYBACK_STATE, {\n      state: HLSPlaybackState.paused,\n    });\n  };\n  private volumeEventHandler = () => {\n    this._volume = this._videoEl.volume;\n  };\n  // eslint-disable-next-line complexity\n  private handleHLSException = (_: any, data: ErrorData) => {\n    console.error(this.TAG, `error type ${data.type} with details ${data.details} is fatal ${data.fatal}`);\n    const details = data.error?.message || data.err?.message || '';\n    const detail = {\n      details: details,\n      fatal: data.fatal,\n    };\n    switch (data.details) {\n      case Hls.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR: {\n        const error = HMSHLSErrorFactory.HLSMediaError.manifestIncompatibleCodecsError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      case Hls.ErrorDetails.FRAG_DECRYPT_ERROR: {\n        const error = HMSHLSErrorFactory.HLSMediaError.fragDecryptError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      case Hls.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR: {\n        const error = HMSHLSErrorFactory.HLSMediaError.bufferIncompatibleCodecsError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      // Below one are network related errors\n      case Hls.ErrorDetails.MANIFEST_LOAD_ERROR: {\n        const error = HMSHLSErrorFactory.HLSNetworkError.manifestLoadError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      case Hls.ErrorDetails.MANIFEST_PARSING_ERROR: {\n        const error = HMSHLSErrorFactory.HLSNetworkError.manifestParsingError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      case Hls.ErrorDetails.LEVEL_LOAD_ERROR: {\n        const error = HMSHLSErrorFactory.HLSNetworkError.layerLoadError(detail);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n      default: {\n        const error = HMSHLSErrorFactory.HLSError(detail, data.type, data.details);\n        this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n        break;\n      }\n    }\n  };\n  private manifestLoadedHandler = (_: any, { levels }: { levels: LevelParsed[] }) => {\n    const layers: HMSHLSLayer[] = mapLayers(this.removeAudioLevels(levels));\n    this.emitEvent(HMSHLSPlayerEvents.MANIFEST_LOADED, {\n      layers,\n    });\n  };\n  private levelUpdatedHandler = (_: any, { level }: { level: number }) => {\n    const qualityLayer: HMSHLSLayer = mapLayer(this._hls.levels[level]);\n    this.emitEvent(HMSHLSPlayerEvents.LAYER_UPDATED, {\n      layer: qualityLayer,\n    });\n  };\n\n  private handleTimeUpdateListener = (_: Event) => {\n    this.emitEvent(HMSHLSPlayerEvents.CURRENT_TIME, this._videoEl.currentTime);\n    const live = this._hls.liveSyncPosition\n      ? this._hls.liveSyncPosition - this._videoEl.currentTime <= HLS_DEFAULT_ALLOWED_MAX_LATENCY_DELAY\n      : false;\n    if (this._isLive !== live) {\n      this._isLive = live;\n      this.emitEvent(HMSHLSPlayerEvents.SEEK_POS_BEHIND_LIVE_EDGE, {\n        isLive: this._isLive,\n      });\n    }\n  };\n  /**\n   * Listen to hlsjs and video related events\n   */\n  private listenHLSEvent() {\n    if (Hls.isSupported()) {\n      this._hls.on(Hls.Events.MANIFEST_LOADED, this.manifestLoadedHandler);\n      this._hls.on(Hls.Events.LEVEL_UPDATED, this.levelUpdatedHandler);\n      this._hls.on(Hls.Events.ERROR, this.handleHLSException);\n      this.subscribeStats();\n    } else if (this._videoEl.canPlayType('application/vnd.apple.mpegurl')) {\n      // code for ios safari, mseNot Supported.\n      this._videoEl.src = this._hlsUrl;\n    }\n    this._videoEl.addEventListener('timeupdate', this.handleTimeUpdateListener);\n    this._videoEl.addEventListener('play', this.playEventHandler);\n    this._videoEl.addEventListener('pause', this.pauseEventHandler);\n    this._videoEl.addEventListener('volumechange', this.volumeEventHandler);\n  }\n\n  private getPlayerConfig(): Partial<HlsConfig> {\n    return {\n      enableWorker: true,\n      maxBufferLength: 20,\n      backBufferLength: 10,\n      abrBandWidthUpFactor: 1,\n    };\n  }\n\n  /**\n   * @param {Array} levels array from hlsJS\n   * @returns a new array with only video levels.\n   */\n  private removeAudioLevels(levels: LevelParsed[]) {\n    return levels.filter(({ videoCodec, width, height }) => !!videoCodec || !!(width && height));\n  }\n}\n", "import Hls, { Fragment } from 'hls.js';\nimport { HMSHLSErrorFactory } from '../error/HMSHLSErrorFactory';\nimport { HMSHLSPlayerListeners } from '../interfaces/events';\nimport { HMSHLSPlayerEvents } from '../utilies/constants';\nimport { metadataPayloadParser } from '../utilies/utils';\n\nexport class HMSHLSTimedMetadata {\n  private hls: Hls;\n  constructor(\n    hls: Hls,\n    private videoEl: HTMLVideoElement,\n    private emitEvent: <E extends HMSHLSPlayerEvents>(\n      eventName: E,\n      eventObject: Parameters<HMSHLSPlayerListeners<E>>[0],\n    ) => boolean,\n  ) {\n    this.hls = hls;\n    this.registerListner();\n  }\n  extractMetaTextTrack = (): TextTrack | null => {\n    const textTrackListCount = this.videoEl.textTracks.length || 0;\n    for (let trackIndex = 0; trackIndex < textTrackListCount; trackIndex++) {\n      const textTrack = this.videoEl.textTracks[trackIndex];\n      if (textTrack?.kind !== 'metadata') {\n        continue;\n      }\n      textTrack.mode = 'showing';\n      return textTrack;\n    }\n    return null;\n  };\n\n  // sync time with cue and trigger event\n  fireCues = (currentAbsTime: number, tolerance: number) => {\n    const cues = this.extractMetaTextTrack()?.cues;\n    if (!cues) {\n      return;\n    }\n    const cuesLength = cues.length;\n    let cueIndex = 0;\n    while (cueIndex < cuesLength) {\n      const cue = cues[cueIndex] as TextTrackCue & {\n        queued: boolean;\n        value: { data: string };\n      };\n      if (cue.queued) {\n        cueIndex++;\n        continue;\n      }\n      // here we are converting base64 to actual data.\n      const data: Record<string, any> = metadataPayloadParser(cue.value.data);\n      const startDate = data.start_date;\n      const endDate = data.end_date;\n      const timeDiff = new Date(startDate).getTime() - currentAbsTime;\n      const duration = new Date(endDate).getTime() - new Date(startDate).getTime();\n      if (timeDiff <= tolerance) {\n        setTimeout(() => {\n          this.emitEvent(HMSHLSPlayerEvents.TIMED_METADATA_LOADED, {\n            id: cue?.id,\n            payload: data.payload,\n            duration: duration,\n            startDate: new Date(startDate),\n            endDate: new Date(endDate),\n          });\n        }, timeDiff);\n        cue.queued = true;\n      }\n      cueIndex++;\n    }\n  };\n\n  // handle time update listener\n  handleTimeUpdateListener = () => {\n    // extract timed metadata text track\n    const metaTextTrack: TextTrack | null = this.extractMetaTextTrack();\n    if (!metaTextTrack || !metaTextTrack.cues) {\n      return;\n    }\n    // @ts-ignore\n    const firstFragProgramDateTime = this.videoEl?.getStartDate() || 0;\n    const currentAbsTime = new Date(firstFragProgramDateTime).getTime() + (this.videoEl.currentTime || 0) * 1000;\n    // fire cue for timed meta data extract\n    this.fireCues(currentAbsTime, 0.25);\n  };\n  /**\n   * Metadata are automatically parsed and added to the video element's\n   * textTrack cue by hlsjs as they come through the stream.\n   * in FRAG_CHANGED, we read the cues and emitEvent HLS_METADATA_LOADED\n   * when the current fragment has a metadata to play.\n   */\n  fragChangeHandler = (_: any, { frag }: { frag: Fragment }) => {\n    if (!this.videoEl) {\n      const error = HMSHLSErrorFactory.HLSMediaError.videoElementNotFound();\n      this.emitEvent(HMSHLSPlayerEvents.ERROR, error);\n    }\n    try {\n      if (this.videoEl.textTracks.length === 0) {\n        return;\n      }\n      const fragStartTime = frag.programDateTime || 0;\n      const fragmentDuration = frag.end - frag.start;\n      this.fireCues(fragStartTime, fragmentDuration);\n    } catch (e) {\n      console.error('FRAG_CHANGED event error', e);\n    }\n  };\n  private registerListner = () => {\n    if (Hls.isSupported()) {\n      this.hls.on(Hls.Events.FRAG_CHANGED, this.fragChangeHandler);\n    } else if (this.videoEl.canPlayType('application/vnd.apple.mpegurl')) {\n      this.videoEl.addEventListener('timeupdate', this.handleTimeUpdateListener);\n    }\n  };\n\n  unregisterListener = () => {\n    this.hls.off(Hls.Events.FRAG_CHANGED, this.fragChangeHandler);\n    this.videoEl.removeEventListener('timeupdate', this.handleTimeUpdateListener);\n  };\n}\n", "export class HMSHLSException extends Error {\n  nativeError?: Error;\n\n  constructor(\n    public name: string,\n    public message: string,\n    public description: string,\n    public isTerminal: boolean = false,\n  ) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSHLSException.prototype);\n  }\n\n  toAnalyticsProperties() {\n    return {\n      error_name: this.name,\n      error_message: this.message,\n      error_description: this.description,\n      is_terminal: this.isTerminal,\n    };\n  }\n\n  addNativeError(error: Error) {\n    this.nativeError = error;\n  }\n\n  toString() {\n    return `{\n      name: ${this.name};\n      message: ${this.message};\n      description: ${this.description};\n      isTerminal: ${this.isTerminal};\n      nativeError: ${this.nativeError?.message};\n    }`;\n  }\n}\n", "export const HLS_DEFAULT_ALLOWED_MAX_LATENCY_DELAY = 5;\n\nexport enum HMSHLSPlayerEvents {\n  TIMED_METADATA_LOADED = 'timed-metadata',\n  SEEK_POS_BEHIND_LIVE_EDGE = 'seek-pos-behind-live-edge',\n\n  CURRENT_TIME = 'current-time',\n  AUTOPLAY_BLOCKED = 'autoplay-blocked',\n\n  MANIFEST_LOADED = 'manifest-loaded',\n  LAYER_UPDATED = 'layer-updated',\n\n  ERROR = 'error',\n  PLAYBACK_STATE = 'playback-state',\n  STATS = 'stats',\n}\n\nexport enum HMSHLSExceptionEvents {\n  MANIFEST_LOAD_ERROR = 'manifest-load-error',\n  MANIFEST_PARSING_ERROR = 'manifest-parsing-error',\n  LAYER_LOAD_ERROR = 'layer-load-error',\n\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifest-incompatible-codecs-error',\n  FRAG_DECRYPT_ERROR = 'frag-decrypt-error',\n  BUFFER_INCOMPATIBLE_CODECS_ERROR = 'buffer-incompatible-codecs-error',\n\n  VIDEO_ELEMENT_NOT_FOUND = 'video-element-not-found',\n  HLS_AUTOPLAY_FAILED = 'hls-autoplay-failed',\n  HLS_URL_NOT_FOUND = 'hls-url-not-found',\n  HLS_ERROR = 'hls-error',\n}\n\nexport enum HLSPlaybackState {\n  playing,\n  paused,\n}\n", "import { HMSHLSException } from './HMSHLSException';\nimport { HMSHLSExceptionEvents } from '../utilies/constants';\n\nexport type HMSHLSErrorDetails = {\n  details: string;\n  fatal?: boolean;\n};\nexport const HMSHLSErrorFactory = {\n  HLSNetworkError: {\n    manifestLoadError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.MANIFEST_LOAD_ERROR,\n        data.details,\n        'Unable to load manifest file',\n        data.fatal,\n      );\n    },\n    manifestParsingError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.MANIFEST_PARSING_ERROR,\n        data.details,\n        'Unable to parse manifest file',\n        data.fatal,\n      );\n    },\n    layerLoadError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.LAYER_LOAD_ERROR,\n        data.details,\n        'Unable to load quality layers',\n        data.fatal,\n      );\n    },\n  },\n  HLSMediaError: {\n    manifestIncompatibleCodecsError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n        data.details,\n        'Incompatible manifest codecs',\n        data.fatal,\n      );\n    },\n    fragDecryptError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.FRAG_DECRYPT_ERROR,\n        data.details,\n        'Unable to decrypt fragment',\n        data.fatal,\n      );\n    },\n    bufferIncompatibleCodecsError(data: HMSHLSErrorDetails): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n        data.details,\n        'Incompatible buffer codecs',\n        data.fatal,\n      );\n    },\n    videoElementNotFound(): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.VIDEO_ELEMENT_NOT_FOUND,\n        'Video element not found',\n        'Video element not found',\n        false,\n      );\n    },\n    autoplayFailed(): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.HLS_AUTOPLAY_FAILED,\n        'Failed to autoplay',\n        'Failed to autoplay',\n        false,\n      );\n    },\n    hlsURLNotFound(msg?: string): HMSHLSException {\n      return new HMSHLSException(\n        HMSHLSExceptionEvents.HLS_URL_NOT_FOUND,\n        msg || 'hls url not found',\n        msg || 'hls url not found',\n        true,\n      );\n    },\n  },\n  HLSError: (\n    data: HMSHLSErrorDetails,\n    name: string | HMSHLSExceptionEvents = HMSHLSExceptionEvents.HLS_ERROR,\n    description = 'Hls error',\n  ): HMSHLSException => {\n    return new HMSHLSException(name, data.details, description, data.fatal);\n  },\n};\n", "import { Level, LevelParsed } from 'hls.js';\nimport { HMSHLSLayer } from '../interfaces/IHMSHLSLayer';\n\n/**\n *\n * @param payload a base64 string coming from backend\n * @returns a parsed data which contains payload, start_date, end_date, version\n */\nexport const metadataPayloadParser = (payload: string): Record<string, any> => {\n  try {\n    const data = window?.atob(payload);\n    const parsedData = JSON.parse(data);\n    return parsedData;\n  } catch (e) {\n    return { payload };\n  }\n};\n\n/**\n * map Level[] to HMSHLSLayer[]\n */\nexport const mapLayers = (levels: Level[] | LevelParsed[]): HMSHLSLayer[] => {\n  return levels.map((level: Level | LevelParsed) => mapLayer(level));\n};\n\n/**\n * map Level[] to HMSHLSLayer[]\n */\nexport const mapLayer = (quality: Level | LevelParsed): HMSHLSLayer => {\n  return {\n    resolution: quality.attrs?.RESOLUTION,\n    bitrate: quality.bitrate,\n    height: quality.height,\n    id: quality.id,\n    url: quality.url[0],\n    width: quality.width,\n  };\n};\n", "import { HlsPlayerStats } from '@100mslive/hls-stats';\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport { HMSHLSLayer } from './IHMSHLSLayer';\nimport { HMSHLSException } from '../error/HMSHLSException';\nimport { HLSPlaybackState, HMSHLSPlayerEvents } from '../utilies/constants';\n\ntype HMSHLSListenerDataMapping = {\n  [HMSHLSPlayerEvents.SEEK_POS_BEHIND_LIVE_EDGE]: HMSHLSStreamLive;\n  [HMSHLSPlayerEvents.TIMED_METADATA_LOADED]: HMSHLSCue;\n  [HMSHLSPlayerEvents.STATS]: HlsPlayerStats;\n  [HMSHLSPlayerEvents.PLAYBACK_STATE]: HMSHLSPlaybackState;\n\n  [HMSHLSPlayerEvents.ERROR]: HMSHLSException;\n  [HMSHLSPlayerEvents.CURRENT_TIME]: number;\n  [HMSHLSPlayerEvents.AUTOPLAY_BLOCKED]: HMSHLSException;\n\n  [HMSHLSPlayerEvents.MANIFEST_LOADED]: HMSHLSManifestLoaded;\n  [HMSHLSPlayerEvents.LAYER_UPDATED]: HMSHLSLayerUpdated;\n};\n\nexport type HMSHLSPlayerListeners<E extends HMSHLSPlayerEvents> = (data: HMSHLSListenerDataMapping[E], name: E) => void;\n\nexport interface HMSHLSStreamLive {\n  isLive: boolean;\n}\nexport interface HMSHLSPlaybackState {\n  state: HLSPlaybackState;\n}\nexport interface HMSHLSCue {\n  id?: string;\n  payload: string;\n  duration: number;\n  startDate: Date;\n  endDate?: Date;\n}\n\nexport interface HMSHLSManifestLoaded {\n  layers: HMSHLSLayer[];\n}\nexport interface HMSHLSLayerUpdated {\n  layer: HMSHLSLayer;\n}\nexport interface IHMSHLSPlayerEventEmitter {\n  on<E extends HMSHLSPlayerEvents>(eventName: E, listener: HMSHLSPlayerListeners<E>): void;\n\n  off<E extends HMSHLSPlayerEvents>(eventName: E, listener?: HMSHLSPlayerListeners<E>): void;\n}\n\nexport class HMSHLSPlayerEventEmitter implements IHMSHLSPlayerEventEmitter {\n  private eventEmitter: EventEmitter;\n  constructor() {\n    this.eventEmitter = new EventEmitter();\n  }\n  on<E extends HMSHLSPlayerEvents>(eventName: E, listener: HMSHLSPlayerListeners<E>): void {\n    this.eventEmitter.on(eventName, listener);\n  }\n\n  off<E extends HMSHLSPlayerEvents>(eventName: E, listener: HMSHLSPlayerListeners<E>) {\n    this.eventEmitter.off(eventName, listener);\n  }\n\n  emitEvent<E extends HMSHLSPlayerEvents>(eventName: E, eventObject: Parameters<HMSHLSPlayerListeners<E>>[0]): boolean {\n    return this.eventEmitter.emit(eventName, eventObject, eventName);\n  }\n\n  removeAllListeners<E extends HMSHLSPlayerEvents>(eventName?: E): void {\n    this.eventEmitter.removeAllListeners(eventName);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
