{
  "version": 3,
  "sources": ["../src/HMSVirtualBackgroundPlugin.ts", "../src/defineTFLite.ts", "../src/HMSVBPlugin.ts", "../src/interfaces.ts"],
  "sourcesContent": ["/* eslint-disable complexity */\nimport { decompressFrames, parseGIF } from 'gifuct-js';\nimport {\n  HMSPluginSupportResult,\n  HMSPluginUnsupportedTypes,\n  HMSVideoPlugin,\n  HMSVideoPluginType,\n} from '@100mslive/hms-video';\nimport '@tensorflow/tfjs-backend-webgl';\nimport { loadTFLite } from './defineTFLite';\n\nconst TAG = 'VBProcessor';\nconst DEFAULT_DELAY = 33;\nconst pkg = require('../package.json');\n\nconst minVideoWidthForSharpening = 214;\nconst maxVideoWidthForSharpening = 855;\nconst minVideoHeightForSharpening = 120;\nconst maxVideoHeightForSharpening = 720;\n\nexport class HMSVirtualBackgroundPlugin implements HMSVideoPlugin {\n  background: string | HTMLImageElement;\n  personMaskWidth: number;\n  personMaskHeight: number;\n  isVirtualBackground: boolean;\n  backgroundImage: HTMLImageElement | null;\n  backgroundVideo: HTMLVideoElement | null;\n  backgroundType = 'none';\n  loadModelCalled: boolean;\n  blurValue: any;\n  tfLite: any;\n  tfLitePromise: any;\n  modelName: string;\n\n  input: HTMLCanvasElement | null;\n  output: HTMLCanvasElement | null;\n  outputCtx: CanvasRenderingContext2D | null;\n  timerID: number;\n  imageAspectRatio: number;\n\n  personMaskPixelCount: number;\n  personMask: ImageData;\n  personMaskCanvas: HTMLCanvasElement;\n  personMaskCtx: any;\n  filters: any;\n  enableSharpening?: boolean | false;\n\n  gifFrames: any;\n  gifFramesIndex: number;\n  gifFrameImageData: any;\n  tempGifCanvas: HTMLCanvasElement;\n  tempGifContext: any;\n  giflocalCount: number;\n\n  constructor(background: string, enableSharpening = false) {\n    this.background = background;\n    this.enableSharpening = enableSharpening;\n\n    this.backgroundImage = null;\n    this.backgroundVideo = null;\n\n    this.personMaskWidth = 256;\n    this.personMaskHeight = 144;\n    this.isVirtualBackground = false;\n    this.blurValue = '10px';\n    this.loadModelCalled = false;\n    this.tfLite = null;\n    this.modelName = 'landscape-segmentation';\n\n    this.outputCtx = null;\n    this.input = null;\n    this.output = null;\n    this.timerID = 0;\n    this.imageAspectRatio = 1;\n\n    this.personMaskPixelCount = this.personMaskWidth * this.personMaskHeight;\n    this.personMask = new ImageData(this.personMaskWidth, this.personMaskHeight);\n    this.personMaskCanvas = document.createElement('canvas');\n    this.personMaskCanvas.width = this.personMaskWidth;\n    this.personMaskCanvas.height = this.personMaskHeight;\n    this.personMaskCtx = this.personMaskCanvas.getContext('2d');\n\n    this.filters = {};\n    this.gifFrames = null;\n    this.gifFramesIndex = 0;\n    this.gifFrameImageData = null;\n    this.tempGifCanvas = document.createElement('canvas');\n    this.tempGifContext = this.tempGifCanvas.getContext('2d');\n    this.giflocalCount = 0;\n    this.enableSharpening = enableSharpening;\n\n    this.log(TAG, 'Virtual Background plugin created');\n    this.setBackground(this.background);\n  }\n\n  async init(): Promise<void> {\n    if (!this.loadModelCalled) {\n      this.log(TAG, 'PREVIOUS LOADED MODEL IS ', this.tfLite);\n      this.loadModelCalled = true;\n      this.tfLitePromise = loadTFLite();\n      this.tfLite = await this.tfLitePromise;\n    } else {\n      //either it is loading or loaded\n      await this.tfLitePromise;\n    }\n    if (this.enableSharpening) {\n      this.initSharpenFilter();\n    }\n  }\n\n  /*\n  @depreceated\n   */\n  isSupported(): boolean {\n    //support chrome, firefox, edge TODO: check this\n    return (\n      navigator.userAgent.indexOf('Chrome') !== -1 ||\n      navigator.userAgent.indexOf('Firefox') !== -1 ||\n      navigator.userAgent.indexOf('Edg') !== -1 ||\n      navigator.userAgent.indexOf('Edge') !== -1\n    );\n  }\n\n  checkSupport(): HMSPluginSupportResult {\n    const browserResult = {} as HMSPluginSupportResult;\n    if (['Chrome', 'Firefox', 'Edg', 'Edge'].some(value => navigator.userAgent.indexOf(value) !== -1)) {\n      browserResult.isSupported = true;\n    } else {\n      browserResult.isSupported = false;\n      browserResult.errType = HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED;\n      browserResult.errMsg = 'browser not supported for plugin, see docs';\n    }\n\n    return browserResult;\n  }\n\n  getName(): string {\n    return pkg.name;\n  }\n\n  getPluginType(): HMSVideoPluginType {\n    return HMSVideoPluginType.TRANSFORM;\n  }\n\n  async setBackground(path?: string | HTMLImageElement | HTMLVideoElement) {\n    if (path !== '') {\n      if (path === 'none') {\n        this.log(TAG, 'setting background to :', path);\n        this.background = 'none';\n        this.backgroundType = 'none';\n        this.isVirtualBackground = false;\n      } else if (path === 'blur') {\n        this.log(TAG, 'setting background to :', path);\n        this.background = 'blur';\n        this.backgroundType = 'blur';\n        this.isVirtualBackground = false;\n      } else if (path instanceof HTMLImageElement) {\n        this.log('setting background to image', path);\n        const img = await this.setImage(path as HTMLImageElement);\n        if (!img || !img.complete || !img.naturalHeight) {\n          throw new Error('Invalid image. Provide a valid and successfully loaded HTMLImageElement');\n        } else {\n          this.isVirtualBackground = true;\n          this.backgroundImage = img;\n          this.backgroundType = 'image';\n        }\n      } else if (path instanceof HTMLVideoElement) {\n        this.log('setting background to video', path);\n        this.backgroundVideo = path as HTMLVideoElement;\n        this.backgroundVideo.crossOrigin = 'anonymous';\n        this.backgroundVideo.muted = true;\n        this.backgroundVideo.loop = true;\n        this.backgroundVideo.oncanplaythrough = async () => {\n          if (this.backgroundVideo != null) {\n            await this.backgroundVideo!.play();\n            this.isVirtualBackground = true;\n            this.backgroundType = 'video';\n          }\n        };\n      } else {\n        console.log('setting gif to background');\n        this.gifFrames = await this.setGiF(path as string);\n        if (this.gifFrames != null && this.gifFrames.length > 0) {\n          this.backgroundType = 'gif';\n          this.isVirtualBackground = true;\n        } else {\n          throw new Error('Invalid background supplied, see the docs to check supported background type');\n        }\n      }\n    } else {\n      throw new Error('Invalid background supplied, see the docs to check supported background type');\n    }\n  }\n\n  stop(): void {\n    if (this.isVirtualBackground) {\n      this.backgroundImage?.removeAttribute('src');\n      this.backgroundVideo?.removeAttribute('src');\n      if (this.backgroundType === 'video') {\n        this.backgroundVideo!.loop = false;\n        this.backgroundVideo = null;\n      }\n    }\n    if (this.outputCtx) {\n      this.outputCtx!.fillStyle = `rgb(0, 0, 0)`;\n      this.outputCtx!.fillRect(0, 0, this.output!.width, this.output!.height);\n    }\n\n    //gif related\n    this.gifFrameImageData = null;\n    this.gifFrames = null;\n    this.giflocalCount = 0;\n    this.gifFramesIndex = 0;\n  }\n\n  processVideoFrame(\n    input: HTMLCanvasElement,\n    output: HTMLCanvasElement,\n    skipProcessing?: boolean,\n  ): Promise<void> | void {\n    if (!input || !output) {\n      throw new Error('Plugin invalid input/output');\n    }\n\n    this.input = input;\n    this.output = output;\n\n    const ctx = output.getContext('2d');\n    if (ctx!.canvas.width !== input.width) {\n      ctx!.canvas.width = input.width;\n    }\n    if (ctx!.canvas.height !== input.height) {\n      ctx!.canvas.height = input.height;\n    }\n\n    if (this.backgroundType === 'video') {\n      this.backgroundVideo!.width = input.width;\n      this.backgroundVideo!.height = input.height;\n    }\n\n    this.outputCtx = ctx!;\n    this.imageAspectRatio = input.width / input.height;\n    if (this.imageAspectRatio <= 0) {\n      throw new Error('Invalid input width/height');\n    }\n\n    const process = async () => {\n      await this.runSegmentation(skipProcessing);\n    };\n\n    if (this.background === 'none' && !this.isVirtualBackground) {\n      this.outputCtx!.globalCompositeOperation = 'copy';\n      this.outputCtx!.filter = 'none';\n      this.outputCtx!.drawImage(input, 0, 0, input.width, input.height);\n    } else {\n      process();\n    }\n  }\n\n  private async setImage(image: HTMLImageElement): Promise<any> {\n    image.crossOrigin = 'anonymous';\n    return new Promise((resolve, reject) => {\n      image.onload = () => resolve(image);\n      image.onerror = reject;\n    });\n  }\n\n  private setGiF(url: string): Promise<any> {\n    return fetch(url)\n      .then(resp => resp.arrayBuffer())\n      .then(buff => parseGIF(buff))\n      .then(gif => {\n        return decompressFrames(gif, true);\n      });\n  }\n\n  private log(tag: string, ...data: any[]) {\n    console.info(tag, ...data);\n  }\n\n  private resizeInputData() {\n    this.personMaskCtx!.drawImage(\n      this.input,\n      0,\n      0,\n      this.input!.width,\n      this.input!.height,\n      0,\n      0,\n      this.personMaskWidth,\n      this.personMaskHeight,\n    );\n\n    const imageData = this.personMaskCtx!.getImageData(0, 0, this.personMaskWidth, this.personMaskHeight);\n    //\n    const inputMemoryOffset = this.tfLite._getInputMemoryOffset() / 4;\n    for (let i = 0; i < this.personMaskPixelCount; i++) {\n      this.tfLite.HEAPF32[inputMemoryOffset + i * 3] = imageData.data[i * 4] / 255;\n      this.tfLite.HEAPF32[inputMemoryOffset + i * 3 + 1] = imageData.data[i * 4 + 1] / 255;\n      this.tfLite.HEAPF32[inputMemoryOffset + i * 3 + 2] = imageData.data[i * 4 + 2] / 255;\n    }\n  }\n  private infer(skipProcessing?: boolean) {\n    if (!skipProcessing) {\n      this.tfLite._runInference();\n    }\n    const outputMemoryOffset = this.tfLite._getOutputMemoryOffset() / 4;\n\n    for (let i = 0; i < this.personMaskPixelCount; i++) {\n      if (this.modelName === 'meet') {\n        const background = this.tfLite.HEAPF32[outputMemoryOffset + i * 2];\n        const person = this.tfLite.HEAPF32[outputMemoryOffset + i * 2 + 1];\n        const shift = Math.max(background, person);\n        const backgroundExp = Math.exp(background - shift);\n        const personExp = Math.exp(person - shift);\n        // Sets only the alpha component of each pixel.\n        this.personMask.data[i * 4 + 3] = (255 * personExp) / (backgroundExp + personExp);\n      } else if (this.modelName === 'landscape-segmentation') {\n        const person = this.tfLite.HEAPF32[outputMemoryOffset + i];\n        this.personMask.data[i * 4 + 3] = 255 * person;\n      }\n    }\n\n    this.personMaskCtx!.putImageData(this.personMask, 0, 0);\n  }\n\n  private postProcessing() {\n    this.outputCtx!.globalCompositeOperation = 'copy';\n    this.outputCtx!.filter = 'none';\n\n    if (this.isVirtualBackground) {\n      this.outputCtx!.filter = 'blur(4px)';\n    } else {\n      this.outputCtx!.filter = 'blur(8px)';\n    }\n    this.drawPersonMask();\n    this.outputCtx!.globalCompositeOperation = 'source-in';\n    this.outputCtx!.filter = 'none';\n    // //Draw the foreground\n    this.outputCtx!.drawImage(this.input!, 0, 0);\n\n    if (\n      this.enableSharpening &&\n      this.output!.width > minVideoWidthForSharpening && // minimum and maximum resolution to enable sharpening filter\n      this.output!.height > minVideoHeightForSharpening &&\n      this.output!.width < maxVideoWidthForSharpening &&\n      this.output!.height < maxVideoHeightForSharpening\n    ) {\n      this.sharpenFilter();\n    }\n\n    // //Draw the background\n    this.drawSegmentedBackground();\n  }\n\n  private sharpenFilter() {\n    // adding sharpening filter to each frame to improve edges and brightness\n    // The basic idea is that you take the weighed sum of a rectangle of pixels from the source image and use that as the output value using convolution filter\n    // It is applied intermediate output with black background and only mask data in frame\n    // Filter currently used is 3 x 3 sharpening filter with values as shown:\n    // [  0, -1,  0,\n    //   -1,  5, -1,\n    //   0, -1,  0 ]\n    const outputImageData = this.outputCtx!.getImageData(0, 0, this.output!.width, this.output!.height);\n\n    // filters you may try\n    // [-1, -1, -1, -1, 9, -1, -1, -1, -1]\n    //[0, -1, 0, -1, 5, -1, 0, -1, 0]\n    const output = this.filters.convolute(outputImageData);\n\n    this.outputCtx!.putImageData(output, 0, 0);\n  }\n\n  private drawPersonMask() {\n    this.outputCtx!.drawImage(\n      this.personMaskCanvas,\n      0,\n      0,\n      this.personMaskWidth,\n      this.personMaskHeight,\n      0,\n      0,\n      this.output!.width,\n      this.output!.height,\n    );\n  }\n\n  private drawSegmentedBackground() {\n    this.outputCtx!.globalCompositeOperation = 'destination-over';\n    this.outputCtx!.imageSmoothingEnabled = true;\n    this.outputCtx!.imageSmoothingQuality = 'high';\n    if (this.isVirtualBackground) {\n      if (this.backgroundType === 'video' && this.backgroundVideo != null && this.backgroundVideo!.readyState >= 4) {\n        this.fitVideoToBackground();\n      } else if (this.backgroundType === 'image') {\n        this.fitImageToBackground();\n      } else if (this.backgroundType === 'gif') {\n        if (this.giflocalCount > this.gifFrames[this.gifFramesIndex].delay / DEFAULT_DELAY) {\n          this.gifFramesIndex++;\n          if (this.gifFramesIndex >= this.gifFrames.length) {\n            this.gifFramesIndex = 0;\n          }\n          this.giflocalCount = 0;\n        } else {\n          this.giflocalCount++;\n        }\n        this.fitGifToBackground();\n      }\n    } else {\n      this.addBlurToBackground();\n    }\n  }\n\n  private async runSegmentation(skipProcessing?: boolean) {\n    if (this.tfLite) {\n      // const start = performance.now();\n\n      this.resizeInputData();\n      await this.infer(skipProcessing);\n      this.postProcessing();\n      // const end = performance.now();\n      // this.log(TAG,\"time taken\",end -start);\n    }\n  }\n\n  private fitVideoToBackground() {\n    this.fitData(this.backgroundVideo, this.backgroundVideo!.videoWidth, this.backgroundVideo!.videoHeight);\n  }\n\n  private fitImageToBackground() {\n    this.fitData(this.backgroundImage, this.backgroundImage!.width, this.backgroundImage!.height);\n  }\n\n  private fitGifToBackground() {\n    if (this.gifFrameImageData == null) {\n      const dims = this.gifFrames[this.gifFramesIndex].dims;\n      this.tempGifCanvas!.width = dims.width;\n      this.tempGifCanvas!.height = dims.height;\n      this.gifFrameImageData = this.tempGifContext.createImageData(dims.width, dims.height);\n    }\n    // set the patch data as an override\n    this.gifFrameImageData.data.set(this.gifFrames[this.gifFramesIndex].patch);\n    this.tempGifContext.putImageData(this.gifFrameImageData, 0, 0);\n\n    this.fitData(this.tempGifCanvas, this.gifFrameImageData!.width, this.gifFrameImageData!.height);\n  }\n\n  private fitData(data: any, dataWidth: number, dataHeight: number) {\n    let inputWidth: any, inputHeight: any, xoffset: any, yoffset: any;\n    if (dataWidth / dataHeight < this.imageAspectRatio) {\n      inputWidth = dataWidth;\n      inputHeight = dataWidth / this.imageAspectRatio;\n      xoffset = 0;\n      yoffset = (dataHeight - inputHeight) / 2;\n    } else {\n      inputHeight = dataHeight;\n      inputWidth = dataHeight * this.imageAspectRatio;\n      yoffset = 0;\n      xoffset = (dataWidth - inputWidth) / 2;\n    }\n    this.outputCtx!.drawImage(\n      data,\n      xoffset,\n      yoffset,\n      inputWidth,\n      inputHeight,\n      0,\n      0,\n      this.output!.width,\n      this.output!.height,\n    );\n  }\n\n  private async addBlurToBackground() {\n    let blurValue = '15px';\n    if (this.input!.width <= 160) {\n      blurValue = '5px';\n    } else if (this.input!.width <= 320) {\n      blurValue = '10px';\n    } else if (this.input!.width <= 640) {\n      blurValue = '15px';\n    } else if (this.input!.width <= 960) {\n      blurValue = '20px';\n    } else if (this.input!.width <= 1280) {\n      blurValue = '25px';\n    } else if (this.input!.width <= 1920) {\n      blurValue = '30px';\n    }\n\n    this.outputCtx!.filter = `blur(${blurValue})`;\n    this.outputCtx!.drawImage(this.input!, 0, 0, this.output!.width, this.output!.height);\n  }\n\n  private initSharpenFilter(): any {\n    this.filters.tmpCanvas = document.createElement('canvas');\n    this.filters.tmpCtx = this.filters.tmpCanvas.getContext('2d');\n\n    this.filters.createImageData = (w: number, h: number) => {\n      return this.filters.tmpCtx.createImageData(w, h);\n    };\n\n    this.filters.convolute = (pixels: ImageData, weights = [0, -1, 0, -1, 5, -1, 0, -1, 0], opaque: boolean) => {\n      const side = Math.round(Math.sqrt(weights.length));\n\n      const halfSide = Math.floor(side / 2);\n      const src = pixels.data;\n      const sw = pixels.width;\n      const sh = pixels.height;\n      // pad output by the convolution matrix\n      const w = sw;\n      const h = sh;\n      const output = this.filters.createImageData(w, h);\n      const dst = output.data;\n      // go through the destination image pixels\n      const alphaFac = opaque ? 1 : 0;\n      for (let y = 0; y < h; y = y + 1) {\n        for (let x = 0; x < w; x = x + 1) {\n          const dstOff = (y * w + x) * 4;\n\n          if (src[dstOff + 3] === 0) {\n            continue;\n          } else if (x < w && y < h) {\n            const sy = y;\n            const sx = x;\n\n            // calculate the weighed sum of the source image pixels that\n            // fall under the convolution matrix\n            let r = 0,\n              g = 0,\n              b = 0,\n              a = 0;\n            for (let cy = 0; cy < side; cy++) {\n              for (let cx = 0; cx < side; cx++) {\n                const scy = sy + cy - halfSide;\n                const scx = sx + cx - halfSide;\n                if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\n                  const srcOff = (scy * sw + scx) * 4;\n                  const wt = weights[cy * side + cx];\n                  r += src[srcOff] * wt;\n                  g += src[srcOff + 1] * wt;\n                  b += src[srcOff + 2] * wt;\n                  a += src[srcOff + 3] * wt;\n                }\n              }\n            }\n            dst[dstOff] = r;\n            dst[dstOff + 1] = g;\n            dst[dstOff + 2] = b;\n            dst[dstOff + 3] = a + alphaFac * (255 - a);\n          }\n        }\n      }\n      return output;\n    };\n  }\n}\n", "const pkg = require('../package.json');\nconst BASE_URL = `https://unpkg.com/${pkg.name}/src`;\nconst TAG = 'VBProcessor';\nconst TFLITE_JS_FILE = 'tflite/tflite.js';\nconst TFLITE_SIMD_JS_FILE = 'tflite/tflite-simd.js';\nconst MODEL_FILE_NAME = 'models/selfie_segmentation_landscape.tflite';\n\nconst loadScript = (src: string) => {\n  return new Promise(function (resolve, reject) {\n    const s = document.createElement('script');\n    s.src = src;\n    s.onload = resolve;\n    s.onerror = reject;\n    document.head.appendChild(s);\n  });\n};\n\nconst loadTFLiteModel = async () => {\n  let tfLite: any;\n  let path = `${BASE_URL}/${TFLITE_SIMD_JS_FILE}`;\n  await loadScript(path);\n  try {\n    //@ts-ignore\n    tfLite = await createTFLiteSIMDModule();\n  } catch {\n    console.warn('SIMD not supported. You may experience poor virtual background effect.');\n    path = `${BASE_URL}/${TFLITE_JS_FILE}`;\n    await loadScript(path);\n    // @ts-ignore\n    tfLite = await createTFLiteModule();\n  }\n  return tfLite;\n};\n\nconst loadTFLite = async () => {\n  const modelPath = `${BASE_URL}/${MODEL_FILE_NAME}`;\n  const [tfLite, modelResponse] = await Promise.all([loadTFLiteModel(), fetch(modelPath)]);\n\n  const model = await modelResponse.arrayBuffer();\n  const modelBufferOffset = tfLite._getModelBufferMemoryOffset();\n  tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);\n  tfLite._loadModel(model.byteLength);\n\n  console.debug(TAG, 'Input memory offset:', tfLite._getInputMemoryOffset());\n  console.debug(TAG, 'Input height:', tfLite._getInputHeight());\n  console.debug(TAG, 'Input width:', tfLite._getInputWidth());\n  console.debug(TAG, 'Input channels:', tfLite._getInputChannelCount());\n\n  return tfLite;\n};\n\nexport { loadTFLite };\n", "/* eslint-disable complexity */\nimport { Results as MediaPipeResults, SelfieSegmentation } from '@mediapipe/selfie_segmentation';\nimport { decompressFrames, parseGIF } from 'gifuct-js';\nimport {\n  HMSPluginSupportResult,\n  HMSPluginUnsupportedTypes,\n  HMSVideoPlugin,\n  HMSVideoPluginType,\n} from '@100mslive/hms-video';\nimport { HMSBackgroundInput, HMSVirtualBackground, HMSVirtualBackgroundTypes } from './interfaces';\n\nexport class HMSVBPlugin implements HMSVideoPlugin {\n  private TAG = '[HMSVBPlugin]';\n  private background: HMSVirtualBackground;\n  private backgroundType: HMSVirtualBackgroundTypes = HMSVirtualBackgroundTypes.NONE;\n  private segmentation!: SelfieSegmentation;\n  private outputCanvas?: HTMLCanvasElement;\n  private outputCtx?: CanvasRenderingContext2D | null;\n\n  private gifFrames: any;\n  private gifFramesIndex: number;\n  private gifFrameImageData: any;\n  private tempGifCanvas: HTMLCanvasElement;\n  private tempGifContext: CanvasRenderingContext2D | null;\n  private prevResults?: MediaPipeResults;\n  private input?: HTMLCanvasElement;\n\n  constructor(background: HMSVirtualBackground, backgroundType: HMSVirtualBackgroundTypes) {\n    this.background = background;\n    this.backgroundType = backgroundType;\n    this.gifFrames = null;\n    this.gifFramesIndex = 0;\n    this.gifFrameImageData = null;\n    this.tempGifCanvas = document.createElement('canvas');\n    this.tempGifContext = this.tempGifCanvas.getContext('2d');\n\n    this.setBackground(this.background, this.backgroundType);\n    this.log('Virtual background plugin initialised');\n  }\n\n  isSupported(): boolean {\n    return this.checkSupport().isSupported;\n  }\n\n  checkSupport(): HMSPluginSupportResult {\n    const browserResult = {} as HMSPluginSupportResult;\n    if (['Chrome', 'Firefox', 'Edg', 'Edge'].some(value => navigator.userAgent.indexOf(value) !== -1)) {\n      browserResult.isSupported = true;\n    } else {\n      browserResult.isSupported = false;\n      browserResult.errType = HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED;\n      browserResult.errMsg = 'browser not supported for plugin, see docs';\n    }\n\n    return browserResult;\n  }\n\n  getName(): string {\n    return 'HMSVB';\n  }\n\n  getPluginType(): HMSVideoPluginType {\n    return HMSVideoPluginType.TRANSFORM;\n  }\n\n  async init(): Promise<void> {\n    if (!this.segmentation) {\n      this.segmentation = new SelfieSegmentation({\n        locateFile: (file: string) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1/${file}`;\n        },\n      });\n      this.segmentation.setOptions({ selfieMode: false, modelSelection: 1 });\n      this.segmentation.onResults(this.handleResults);\n    }\n  }\n\n  /**\n   * For bgType HMSVirtualBackgroundTypes.IMAGE pass bg as an image element\n   * For bgType HMSVirtualBackgroundTypes.VIDEO pass video\n   * For bgType HMSVirtualBackgroundTypes.GIF pass the gif url\n   * @param {HMSVirtualBackground} background\n   * @param {HMSVirtualBackgroundTypes} backgroundType\n   */\n  async setBackground(background: HMSVirtualBackground, backgroundType: HMSVirtualBackgroundTypes) {\n    if (!background) {\n      throw new Error('Invalid background supplied, see the docs to check supported background type');\n    }\n    this.prevResults = undefined;\n    switch (backgroundType) {\n      case HMSVirtualBackgroundTypes.NONE:\n      case HMSVirtualBackgroundTypes.BLUR:\n        this.background = background;\n        this.backgroundType = backgroundType;\n        break;\n      case HMSVirtualBackgroundTypes.IMAGE:\n        this.log('setting background to image', background);\n        // eslint-disable-next-line no-case-declarations\n        const img = await this.setImage(background as HTMLImageElement);\n        if (!img || !img.complete || !img.naturalHeight) {\n          throw new Error('Invalid image. Provide a valid and successfully loaded HTMLImageElement');\n        } else {\n          this.background = img;\n          this.backgroundType = HMSVirtualBackgroundTypes.IMAGE;\n        }\n        break;\n      case HMSVirtualBackgroundTypes.VIDEO:\n        this.log('setting background to video', background);\n        this.backgroundType = HMSVirtualBackgroundTypes.NONE;\n        this.background = background as HTMLVideoElement;\n        this.background.crossOrigin = 'anonymous';\n        this.background.muted = true;\n        this.background.loop = true;\n        this.background.playsInline = true;\n        this.background.oncanplaythrough = async () => {\n          if (this.background && this.background instanceof HTMLVideoElement) {\n            try {\n              await this.background.play();\n              this.backgroundType = HMSVirtualBackgroundTypes.VIDEO;\n            } catch (e) {\n              this.log('failed to play background', background);\n            }\n          }\n        };\n        break;\n      case HMSVirtualBackgroundTypes.CANVAS:\n        this.background = background;\n        this.backgroundType = HMSVirtualBackgroundTypes.CANVAS;\n        break;\n      case HMSVirtualBackgroundTypes.GIF:\n        this.log('setting gif to background', background);\n        this.backgroundType = HMSVirtualBackgroundTypes.NONE;\n        this.background = background as string;\n        this.gifFrames = await this.loadGIF(this.background);\n        if (this.gifFrames != null && this.gifFrames.length > 0) {\n          this.backgroundType = HMSVirtualBackgroundTypes.GIF;\n        } else {\n          throw new Error('Invalid background supplied, see the docs to check supported background type');\n        }\n        break;\n      default:\n        this.log(\n          `backgroundType did not match with any of the supported background types - ${HMSVirtualBackgroundTypes}`,\n        );\n    }\n  }\n\n  stop(): void {\n    if (this.backgroundType !== HMSVirtualBackgroundTypes.BLUR && this.background !== HMSVirtualBackgroundTypes.NONE) {\n      this.segmentation?.reset();\n    }\n    //gif related\n    this.gifFrameImageData = null;\n    this.gifFrames = null;\n    this.gifFramesIndex = 0;\n    this.background = HMSVirtualBackgroundTypes.NONE;\n    this.backgroundType = HMSVirtualBackgroundTypes.NONE;\n  }\n\n  async processVideoFrame(input: HTMLCanvasElement, output: HTMLCanvasElement, skipProcessing?: boolean) {\n    if (!input || !output) {\n      throw new Error('Plugin invalid input/output');\n    }\n    this.input = input;\n    output.width = input.width;\n    output.height = input.height;\n    this.outputCanvas = output;\n    this.outputCtx = output.getContext('2d');\n    if (skipProcessing && this.prevResults) {\n      this.handleResults(this.prevResults);\n      return;\n    }\n    if (this.backgroundType === HMSVirtualBackgroundTypes.NONE) {\n      this.outputCtx?.drawImage(input, 0, 0, input.width, input.height);\n      return;\n    }\n    await this.segmentation.send({ image: input });\n  }\n\n  private async setImage(image: HTMLImageElement): Promise<any> {\n    image.crossOrigin = 'anonymous';\n    return new Promise((resolve, reject) => {\n      image.onload = () => resolve(image);\n      image.onerror = reject;\n    });\n  }\n\n  private handleResults = (results: MediaPipeResults) => {\n    if (!this.outputCanvas || !this.outputCtx) {\n      return;\n    }\n    this.outputCtx.save();\n    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    switch (this.backgroundType) {\n      case HMSVirtualBackgroundTypes.IMAGE:\n      case HMSVirtualBackgroundTypes.CANVAS:\n      case HMSVirtualBackgroundTypes.VIDEO:\n        this.renderBackground(results, this.background as HMSBackgroundInput);\n        break;\n      case HMSVirtualBackgroundTypes.GIF:\n        this.renderGIF(results);\n        break;\n      case HMSVirtualBackgroundTypes.BLUR:\n        this.renderBlur(results);\n        break;\n    }\n    this.outputCtx.restore();\n    this.prevResults = results;\n  };\n\n  private loadGIF(url: string): Promise<any> {\n    return fetch(url)\n      .then(resp => resp.arrayBuffer())\n      .then(buff => parseGIF(buff))\n      .then(gif => {\n        return decompressFrames(gif, true);\n      });\n  }\n\n  private log(...data: any[]) {\n    console.debug(this.TAG, ...data);\n  }\n\n  private renderBackground = (results: MediaPipeResults, background: HMSBackgroundInput) => {\n    if (\n      !this.input ||\n      !this.outputCanvas ||\n      !this.outputCtx ||\n      this.backgroundType === HMSVirtualBackgroundTypes.NONE ||\n      this.backgroundType === HMSVirtualBackgroundTypes.BLUR\n    ) {\n      return;\n    }\n    this.outputCtx.filter = 'none';\n    this.outputCtx.imageSmoothingEnabled = true;\n    this.outputCtx.imageSmoothingQuality = 'high';\n    // Only overwrite existing pixels.\n    this.outputCtx.globalCompositeOperation = 'source-out';\n    const bgWidth = background instanceof HTMLVideoElement ? background.videoWidth : background.width;\n    const bgHeight = background instanceof HTMLVideoElement ? background.videoHeight : background.height;\n\n    this.outputCtx.drawImage(\n      background,\n      0,\n      0,\n      bgWidth,\n      bgHeight,\n      0,\n      0,\n      this.outputCanvas.width,\n      this.outputCanvas.height,\n    );\n    this.outputCtx.globalCompositeOperation = 'destination-out';\n    this.outputCtx.drawImage(results.segmentationMask, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    // Only overwrite missing pixels.\n    this.outputCtx.globalCompositeOperation = 'destination-atop';\n    this.outputCtx.drawImage(this.input, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\n  };\n\n  private renderBlur(results: MediaPipeResults) {\n    if (!this.outputCanvas || !this.outputCtx || this.backgroundType !== HMSVirtualBackgroundTypes.BLUR) {\n      return;\n    }\n    this.outputCtx!.filter = 'none';\n    this.outputCtx!.globalCompositeOperation = 'source-out';\n    this.outputCtx?.drawImage(results.image, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    this.outputCtx!.globalCompositeOperation = 'destination-atop';\n    this.outputCtx?.drawImage(results.segmentationMask, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    this.outputCtx!.filter = `blur(${Math.floor(this.outputCanvas.width / 160) * 5}px)`;\n    this.outputCtx?.drawImage(results.image, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\n  }\n\n  private renderGIF(results: MediaPipeResults) {\n    if (\n      !this.outputCanvas ||\n      !this.outputCtx ||\n      !this.tempGifContext ||\n      this.backgroundType !== HMSVirtualBackgroundTypes.GIF\n    ) {\n      return;\n    }\n    if (this.gifFrameImageData == null) {\n      const dims = this.gifFrames[this.gifFramesIndex].dims;\n      this.tempGifCanvas.width = dims.width;\n      this.tempGifCanvas.height = dims.height;\n      this.gifFrameImageData = this.tempGifContext.createImageData(dims.width, dims.height);\n    }\n    // set the patch data as an override\n    this.gifFrameImageData.data.set(this.gifFrames[this.gifFramesIndex].patch);\n    this.tempGifContext.putImageData(this.gifFrameImageData, 0, 0);\n    this.gifFramesIndex = (this.gifFramesIndex + 1) % this.gifFrames.length;\n    this.renderBackground(results, this.tempGifCanvas);\n  }\n}\n", "export type HMSBackgroundInput = HTMLImageElement | HTMLVideoElement | HTMLCanvasElement;\nexport enum HMSVirtualBackgroundTypes {\n  BLUR = 'blur',\n  NONE = 'none',\n  GIF = 'gif',\n  IMAGE = 'image',\n  VIDEO = 'video',\n  CANVAS = 'canvas',\n}\n\nexport type HMSVirtualBackground =\n  | string\n  | HMSVirtualBackgroundTypes.BLUR\n  | HMSVirtualBackgroundTypes.NONE\n  | HMSBackgroundInput;\n"],
  "mappings": "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",
  "names": []
}
